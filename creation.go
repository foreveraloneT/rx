package rx

import (
	"time"
)

// Interval creates a channel that emits an integer at a fixed interval
func Interval(d time.Duration, options ...Option) <-chan Result[int] {
	results := resultCh[int](options...)

	go func() {
		defer close(results)

		ticker := time.NewTicker(d)
		defer ticker.Stop()

		for i := 0; ; i++ {
			<-ticker.C
			results <- Ok(i)
		}
	}()

	return results
}

// Timer creates a channel that emits number 0 and immediately close the channel after the specified duration
func Timer(d time.Duration, options ...Option) <-chan Result[int] {
	results := resultCh[int](options...)

	go func() {
		defer close(results)

		<-time.After(d)
		results <- Ok(0)
	}()

	return results
}

// From creates a channel that emits the values from the provided slice
func From[T any](vv []T, options ...Option) <-chan Result[T] {
	results := resultCh[T](options...)

	go func() {
		defer close(results)

		for _, v := range vv {
			results <- Ok(v)
		}
	}()

	return results
}

// FromChannel creates a Result channel that emits the values from the provided channel.
// Default buffer size is the same as the provided channel.
func FromChannel[T any](ch <-chan T, options ...Option) <-chan Result[T] {
	results := resultCh[T](prepend(WithBufferSize(cap(ch)), options)...)

	go func() {
		defer close(results)

		for v := range ch {
			results <- Ok(v)
		}
	}()

	return results
}

// Of creates a channel that emits the provided values.
// Please note that this function is not receive Option, so the channel is always no buffer.
// If you want to set some Option, please use From function instead
func Of[T any](vv ...T) <-chan Result[T] {
	return From(vv)
}

// Range creates a channel that emits a range of integers
func Range(start int, count int, options ...Option) <-chan Result[int] {
	results := resultCh[int](options...)

	go func() {
		defer close(results)

		for i := start; i < start+count; i++ {
			results <- Ok(i)
		}
	}()

	return results
}

// Generate creates a channel that emits values generated by the provided seed, condition, iterate, and resultSelector functions
func Generate[T any, R any](seed T, condition func(v T) bool, iterate func(v T) T, resultSelector func(v T) R, options ...Option) <-chan Result[R] {
	results := resultCh[R](options...)

	go func() {
		defer close(results)

		for v := seed; condition(v); v = iterate(v) {
			results <- Ok(resultSelector(v))
		}
	}()

	return results
}

// Empty creates a channel that immediately close the channel
func Empty[T any](options ...Option) <-chan Result[T] {
	results := resultCh[T](options...)

	go func() {
		close(results)
	}()

	return results
}

// ThrowError creates a channel that emits an error result
func ThrowError[T any](err error, options ...Option) <-chan Result[T] {
	results := resultCh[T](options...)

	go func() {
		defer close(results)

		results <- Err[T](err)
	}()

	return results
}
